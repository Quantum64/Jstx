package co.q64.jstx.compiler;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import com.google.auto.factory.AutoFactory;
import com.google.auto.factory.Provided;

import co.q64.jstx.annotation.Constants.Author;
import co.q64.jstx.annotation.Constants.Name;
import co.q64.jstx.annotation.Constants.Version;
import co.q64.jstx.compression.Insanity;
import co.q64.jstx.lang.opcode.Chars;
import co.q64.jstx.lang.opcode.OpcodeMarker;
import co.q64.jstx.lang.opcode.Opcodes;
import lombok.Getter;

@AutoFactory
public class CompilerOutput {
	private String author;
	private String version;
	private String name;
	private Opcodes opcodes;
	private Insanity insanity;
	private @Getter boolean success;
	private @Getter String error;
	private List<String> compiledLines, instructionLines;

	protected CompilerOutput(String author, String name, String version, Opcodes opcodes, Insanity insanity) {
		this.author = author;
		this.version = version;
		this.name = name;
		this.opcodes = opcodes;
		this.insanity = insanity;
	}

	protected CompilerOutput(@Provided @Author String author, @Provided @Name String name, @Provided @Version String version, @Provided Opcodes opcodes, @Provided Insanity insanity, String error) {
		this(author, name, version, opcodes, insanity);
		this.error = error;
		this.success = false;
	}

	protected CompilerOutput(@Provided @Author String author, @Provided @Name String name, @Provided @Version String version, @Provided Opcodes opcodes, @Provided Insanity insanity, List<String> compiledLines, List<String> instructionLines) {
		this(author, name, version, opcodes, insanity);
		this.compiledLines = compiledLines;
		this.instructionLines = instructionLines;
		this.success = true;
	}

	public List<String> getDisplayOutput() {
		List<String> result = new ArrayList<>();
		if (success) {
			int offsetLength = 0;
			for (String s : instructionLines) {
				if (s.length() > offsetLength) {
					offsetLength = s.length();
				}
			}
			result.add(getProgram());
			result.add(new String());
			result.add("Size: " + getProgram().length() + " bytes");
			result.add("Instructions: " + instructionLines.size());
			result.add(new String());
			for (int i = 0; i < compiledLines.size(); i++) {
				if (instructionLines.size() <= i) {
					continue;
				}
				String instruction = instructionLines.get(i);
				String offset = new String();
				for (int u = 0; u < offsetLength - instruction.length(); u++) {
					offset += " ";
				}
				String compiled = compiledLines.get(i);
				if (compiled.equals(" ")) {
					compiled = "<whitespace character>";
				}
				result.add((i + 1) + ": " + instruction + offset + " => " + compiled);
			}
			result.add(new String());
			offsetLength = 0;
			for (String s : compiledLines) {
				if (s.length() > offsetLength) {
					offsetLength = s.length();
				}
			}
			for (int i = 0; i < compiledLines.size(); i++) {
				if (instructionLines.size() <= i) {
					continue;
				}
				String instruction = instructionLines.get(i);
				String compiled = compiledLines.get(i);
				String offset = new String();
				String description = opcodes.getDescription(instruction);
				if (instruction.startsWith("load")) {
					description = "Push literal " + instruction.substring(5);
				}
				for (int u = 0; u < offsetLength - compiled.length(); u++) {
					offset += " ";
				}
				if (compiled.equals(" ")) {
					compiled = "<whitespace character>";
				}
				result.add(compiled + offset + " # " + description);
			}
			String program = getProgram();
			if (program.length() % 2 == 1) {
				program += opcodes.getChars(OpcodeMarker.EXIT).getCharacter();
			}
			char[] chars = program.toCharArray();
			StringBuilder compressed = new StringBuilder();
			for (int i = 0; i < chars.length; i += 2) {
				int point = ((Chars.fromCode(String.valueOf(chars[i])).getByte() & 0xff) << 8) | (Chars.fromCode(String.valueOf(chars[i + 1])).getByte() & 0xff);
				compressed.append(insanity.getCharacter(point));
			}
			if (compressed.length() > 0) {
				result.add(new String());
				result.add("With insanity compression (" + chars.length / 2 + " bytes)");
				result.add(compressed.toString());
			}
		} else {
			result.add(error);
		}
		result.add(new String());
		result.add("Generated by " + name + " compiler version " + version + " by " + author + ".");
		return result;
	}

	public String getProgram() {
		return compiledLines.stream().collect(Collectors.joining());
	}
}
